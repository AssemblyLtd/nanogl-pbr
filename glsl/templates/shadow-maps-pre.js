module.exports = function( obj ){
var __t,__p='';
__p+='#define QUALITY_SHADOWS 2\n\n#define QUALITY_SHADOWMAP_SIZE 1024.0\n#define SHADOW_KERNEL (4.0 / QUALITY_SHADOWMAP_SIZE )\n#define SHADOW_COUNT '+
(obj.shadowCount)+
'\n\n';
 for(var i = 0; i<obj.shadowCount; i++){ 
__p+='\n  uniform sampler2D tShadowMap'+
(i)+
';\n';
 } 
__p+='\n\n\n\n\nuniform highp vec2 uShadowKernelRotation;\nuniform highp vec4 uShadowMapSize;\nuniform highp mat4 uShadowMatrices[SHADOW_COUNT];\nuniform highp vec4 uShadowTexelBiasVector[SHADOW_COUNT];\n\n\nhighp float decodeDepthRGB(highp vec3 rgb){\n  return(rgb.x+rgb.y*(1.0/255.0))+rgb.z*(1.0/65025.0);\n}\n\n\n\nfloat resolveShadowNoFiltering(highp float fragZ, sampler2D depth,highp vec2 uv ){\n    return step( fragZ, decodeDepthRGB(texture2D(depth,uv.xy).xyz) );\n}\n\n\nfloat resolveShadow2x1(highp float fragZ, sampler2D depth,highp vec2 uv ){\n\n  highp float coordsPx = uv.x*uShadowMapSize.x;\n  highp float uvMin = floor( coordsPx ) * uShadowMapSize.z;\n  highp float uvMax = ceil(  coordsPx ) * uShadowMapSize.z;\n\n  vec2 occl = vec2(\n    decodeDepthRGB(texture2D(depth,vec2( uvMin, uv.y )).xyz),\n    decodeDepthRGB(texture2D(depth,vec2( uvMax, uv.y )).xyz)\n  );\n\n  occl = step( vec2(fragZ), occl );\n\n  highp float ratio = coordsPx - uvMin*uShadowMapSize.x;\n  return ( ratio * occl.y + occl.x ) - ratio * occl.x;\n\n}\n\nfloat resolveShadow2x2(highp float fragZ, sampler2D depth,highp vec2 uv ){\n\n  highp vec2 coordsPx = uv*uShadowMapSize.xy;\n  highp vec2 uvMin=floor( coordsPx ) *uShadowMapSize.zw;\n  highp vec2 uvMax=ceil(  coordsPx ) *uShadowMapSize.zw;\n\n  vec4 occl = vec4(\n    decodeDepthRGB(texture2D(depth,uvMin).xyz),\n    decodeDepthRGB(texture2D(depth,vec2(uvMax.x,uvMin.y)).xyz),\n    decodeDepthRGB(texture2D(depth,vec2(uvMin.x,uvMax.y)).xyz),\n    decodeDepthRGB(texture2D(depth,uvMax).xyz)\n  );\n\n  occl = step( vec4(fragZ), occl );\n\n  highp vec2 ratio = coordsPx - uvMin*uShadowMapSize.xy;\n  vec2  t = ( ratio.y * occl.zw + occl.xy ) - ratio.y * occl.xy;\n\n  return(ratio.x*t.y+t.x)-ratio.x*t.x;\n}\n\n\nfloat calcLightOcclusions(sampler2D depth, highp vec3 fragCoord, highp vec2 kernelOffset){\n  float s;\n\n  // NO FILTER\n  #if QUALITY_SHADOWS == 1\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy );\n\n\n  // PCF4x1\n  #elif QUALITY_SHADOWS == 2\n\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy - kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x)  );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x)  );\n    s /= 4.0;\n\n  // PCF4x4\n  #elif QUALITY_SHADOWS == 3\n\n    s = resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + kernelOffset                    );\n    s+=resolveShadow2x2( fragCoord.z, depth, fragCoord.xy - kernelOffset                    );\n    s+=resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x)  );\n    s+=resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x)  );\n    s /= 4.0;\n\n  // PCF2x2\n  #elif QUALITY_SHADOWS == 4\n\n    s = resolveShadow2x1( fragCoord.z, depth, fragCoord.xy + kernelOffset );\n    s +=resolveShadow2x1( fragCoord.z, depth, fragCoord.xy - kernelOffset );\n    s /= 2.0;\n\n  #endif\n\n  return s;\n\n}\n\n\n\nvec3 calcShadowPosition( vec4 texelBiasVector, mat4 shadowProjection, vec3 worldNormal, float samplesDelta )\n{\n  float WoP = dot( texelBiasVector, vec4( vWorldPosition, 1.0 ) );\n\n  WoP *= .0005+0.5*samplesDelta;\n\n  highp vec4 fragCoord = shadowProjection * vec4( vWorldPosition + WoP * worldNormal, 1.0);\n  return fragCoord.xyz / fragCoord.w;\n}\n\n\n';
return __p;
}